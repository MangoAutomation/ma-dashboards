/**
 * @copyright 2016 {@link http://infiniteautomation.com|Infinite Automation Systems, Inc.} All rights reserved.
 * @author Jared Wiltshire
 */

define(['amcharts/serial', 'jquery', 'moment'], function(AmCharts, $, moment) {
'use strict';
/**
 * @ngdoc directive
 * @name maDashboards.maSerialChart
 * @restrict E
 * @description
 * `<ma-serial-chart style="height: 300px; width: 100%" series-1-values="point1Values" series-1-point="point1" default-type="column">
</ma-serial-chart>`
 * - The `<ma-serial-chart>` directive allows you to create line and bar charts.
 * - Many different variations on a chart can be created by customizing the attributes.
 * - Values are provided via `<ma-point-values>`. You can provide your time range and rollup settings to `<ma-point-values>`, then pass the values data to `<ma-serial-chart>`.
 * - In the attributes starting with `series...` you will replace `X` with the number of that series starting with 1.
 * - Note, you will need to set a width and height on the element.
 * - [View Demo](/modules/dashboards/web/mdAdmin/#/dashboard/examples/charts/examples/charts/line-chart) / [Advanced Demo](/modules/dashboards/web/mdAdmin/#/dashboard/examples/charts/advanced-chart)
 *
 * @param {array} values Inputs an array of value objects generated by `<ma-point-values>`.
 * @param {array=} points Inputs an array of points from `<ma-point-query>`. ([See Example](/modules/dashboards/web/mdAdmin/#/dashboard/examples/point-arrays/point-array-line-chart))
 * @param {string=} time-format The moment.js time format to be used in displaying timestamps on the X axis.
 * @param {string=} stack-type Stacking mode of the axis. Possible values are: `"none"`, `"regular"`, `"100%"`, `"3d"`.
 * @param {string=} default-type The type of chart used for all graphs. The possible values for chart type are `"line"`, `"smoothedLine"`, `"column"`, or `"step"`.
 * @param {string=} default-color The default color used for all graphs. Can be a color string or hex value.
 * @param {string=} default-axis The defaults axis used for all graphs. Can be `"right"` or `"left"`.
 * @param {string=} default-balloon-text Overides the balloon text with a specified string.
 * @param {array} series-X-values Inputs a values array generated by `<ma-point-values>`.
 * @param {object=} series-X-point Inputs a point object from `<ma-point-list>`.
 * @param {string=} series-X-type The type of chart used for the given series (replace `X` with series number starting with 1). The possible values for chart type are `"line"`, `"smoothedLine"`, `"column"`, or `"step"`.
 * @param {string=} series-X-color The default color used for the given series (replace `X` with series number starting with 1). Can be a color string or hex value.
 * @param {string=} series-X-axis The defaults axis used for the given series (replace `X` with series number starting with 1). Can be `"right"` or `"left"`.
 * @param {string=} series-X-balloon-text Overides the balloon text with a specified string for the given series (replace `X` with series number starting with 1).
 * @param {string=} series-X-title Sets the text in the legend for the given series (replace `X` with series number starting with 1).
 * @param {object=} options extend AmCharts configuration object for customizing design of the chart (see [amCharts](https://docs.amcharts.com/3/javascriptcharts/AmSerialChart))
 *
 * @usage
 * <ma-serial-chart style="height: 300px; width: 100%" series-1-values="point1Values" series-1-point="point1" default-type="column">
</ma-serial-chart>`
 *
 */
function serialChart() {
	var MAX_SERIES = 10;

	var scope = {
		options: '=?',
	    timeFormat: '@',
	    stackType: '@',
	    values: '=?',
	    points: '=?',
	    defaultType: '@',
	    defaultColor: '@',
        defaultAxis: '@',
        defaultBalloonText: '@'
	};

	for (var j = 1; j <= MAX_SERIES; j++) {
		scope['series' + j + 'Values'] = '=';
		scope['series' + j + 'Type'] = '@';
		scope['series' + j + 'Title'] = '@';
		scope['series' + j + 'Color'] = '@';
		scope['series' + j + 'Point'] = '=?';
		scope['series' + j + 'Axis'] = '@';
        scope['series' + j + 'BalloonText'] = '@';
	}

    return {
        restrict: 'E',
        replace: true,
        scope: scope,
        template: '<div class="amchart"></div>',
        link: function ($scope, $element, attrs) {
            var options = defaultOptions();

            if ($scope.timeFormat) {
                options.categoryAxis.parseDates = false;
            }

            if ($scope.stackType) {
                options.valueAxes[0].stackType = $scope.stackType;
            }

            var valueArray = !!attrs.values;

            $.extend(true, options, $scope.options);

            var chart = AmCharts.makeChart($element[0], options);

            $scope.$watch('options', function(newValue, oldValue) {
            	if (newValue === undefined) return;
            	$.extend(true, chart, newValue);
            	chart.validateNow();
            }, true);

            $scope.$watchGroup([
                'defaultType',
                'defaultColor',
                'defaultAxis',
                'defaultBalloonText'
            ], typeOrTitleChanged.bind(null, null));

            var i;
            if (valueArray) {
            	$scope.$watchCollection('values', watchValues);
            	$scope.$watchCollection('points', watchPoints);

            	for (i = 1; i <= MAX_SERIES; i++) {
	        		$scope.$watchGroup([
	        		    'series' + i + 'Type',
	        		    'series' + i + 'Title',
	        		    'series' + i + 'Color',
	        		    'series' + i + 'Axis',
                        'series' + i + 'BalloonText'
	        		], typeOrTitleChanged.bind(null, i));
	        	}
            } else {
            	for (i = 1; i <= MAX_SERIES; i++) {
	        		$scope.$watchGroup([
	        		    'series' + i + 'Type',
	        		    'series' + i + 'Title',
	        		    'series' + i + 'Color',
	        		    'series' + i + 'Point',
	        		    'series' + i + 'Axis',
                        'series' + i + 'BalloonText'
	        		], typeOrTitleChanged.bind(null, i));

	        		$scope.$watchCollection('series' + i + 'Values', valuesChanged.bind(null, i));
	        	}
            }

            function watchValues(newValues, oldValues) {
                chart.dataProvider = newValues;
                chart.validateData();
            }

            function watchPoints(newPoints, oldPoints) {
            	var i, point, graphNum;
            	chart.graphs = [];

            	if (newPoints) {
	            	for (i = 0; i < newPoints.length; i++) {
	            		point = newPoints[i];
	            		if (!point) continue;
	            		setupGraph(i + 1, point);
	            	}
            	}

            	sortGraphs();
                chart.validateData();
            }

            function findGraph(propName, prop, removeGraph) {
                for (var i = 0; i < chart.graphs.length; i++) {
                    if (chart.graphs[i][propName] === prop) {
                    	var graph = chart.graphs[i];
                    	if (removeGraph) chart.graphs.splice(i, 1);
                    	return graph;
                    }
                }
            }

            function typeOrTitleChanged(graphNum, values) {
            	if (isAllUndefined(values)) return;

            	if (graphNum === null) {
            	    // update all graphs
            	    for (var i = 0; i < chart.graphs.length; i++) {
            	        setupGraph(chart.graphs[i]);
            	    }
            	} else {
            	    setupGraph(graphNum);
            	}

            	sortGraphs();
            	chart.validateData();
            }

            function valuesChanged(graphNum, newValues, oldValues) {
            	if (newValues === oldValues && newValues === undefined) return;

            	if (!newValues) {
            		findGraph('graphNum', graphNum, true);
            	} else  {
                	setupGraph(graphNum);
                	sortGraphs();
                }
                updateValues();
            }

            function setupGraph(graphNum, point) {
                var graph;

                // first arg can be the graph itself
                if (typeof graphNum === 'object') {
                    graph = graphNum;
                    graphNum = graph.graphNum;
                } else {
                    graph = findGraph('graphNum', graphNum);
                }

            	if (!point) {
                	if (valueArray) {
                		point = $scope.points[graphNum - 1];
                	} else {
                		point = $scope['series' + graphNum + 'Point'];
                	}
                }

                var graphType = $scope['series' + graphNum + 'Type'] || $scope.defaultType ||
                	(point && point.plotType && point.plotType.toLowerCase()) ||
                	'smoothedLine';

                // change mango plotType to amCharts graphType
                // step and line are equivalent
                if (graphType === 'spline') {
                	graphType = 'smoothedLine';
                }

                if (!graph) {
                    graph = {};
                    chart.graphs.push(graph);
                }
                $.extend(graph, graphType === 'column' ? defaultColumnGraph() : defaultLineGraph());

                graph.graphNum = graphNum;
                graph.id = 'series-' + graphNum;
                graph.xid = point ? point.xid : null;
                graph.valueField = valueArray && point ? 'value_' + point.xid : 'value' + graphNum;
                graph.title = $scope['series' + graphNum + 'Title'] ||
                	(point && point.name) ||
                	('Series ' + graphNum);
                graph.type = graphType;
                graph.lineColor = $scope['series' + graphNum + 'Color'] || $scope.defaultColor ||
                	(point && point.chartColour) ||
                	null;
                graph.valueAxis = $scope['series' + graphNum + 'Axis'] ||  $scope.defaultAxis || 'left';
                graph.balloonText = $scope['series' + graphNum + 'BalloonText'] ||  $scope.defaultBalloonText || '[[value]]';
                var stackType = options.valueAxes[0].stackType;
                if (stackType && stackType !== 'none') {
                	graph.fillAlphas = 0.8;
                }
            }

            function sortGraphs() {
            	chart.graphs.sort(function(a, b) {
                    return a.graphNum - b.graphNum;
                });
            }

            function combine(output, newValues, valueField) {
                if (!newValues) return;

                for (var i = 0; i < newValues.length; i++) {
                    var value = newValues[i];
                    var timestamp = $scope.timeFormat ?
                            moment(value.timestamp).format($scope.timeFormat) :
                            value.timestamp;

                    if (!output[timestamp]) {
                        output[timestamp] = {timestamp: timestamp};
                    }

                    output[timestamp][valueField] = value.value;
                }
            }

            function updateValues() {
            	var values = $scope.timeFormat ? {} : [];

            	for (var i = 1; i <= MAX_SERIES; i++) {
            		var seriesValues = $scope['series' + i + 'Values'];
            		combine(values, seriesValues, 'value' + i);
            	}

                // normalize sparse array or object into dense array
                var output = [];
                for (var timestamp in values) {
                    output.push(values[timestamp]);
                }

                // XXX sparse array to dense array doesnt result in sorted array
                // manually sort here
                if (output.length && typeof output[0].timestamp === 'number') {
                    output.sort(function(a,b) {
                        return a.timestamp - b.timestamp;
                    });
                }

                chart.dataProvider = output;
                chart.validateData();
            }

            function isAllUndefined(a) {
            	for (var i = 0; i < a.length; i++) {
            		if (a[i] !== undefined) return false;
            	}
            	return true;
            }
        }
    };
}

function defaultLineGraph() {
    return {
        fillAlphas: 0,
        lineAlpha: 0.8,
        lineThickness: 2.0
    };
}

function defaultColumnGraph() {
    return {
        fillAlphas: 0.8,
        lineAlpha: 0.9,
        lineThickness: 1
    };
}

function defaultOptions() {
    return {
        type: "serial",
        theme: "light",
        addClassNames: true,
        dataProvider: [],
        valueAxes: [{
        	id: "left",
            position: "left"
        },{
        	id: "right",
            position: "right"
        },{
        	id: "left-2",
            position: "left",
            offset: 50
        },{
        	id: "right-2",
            position: "right",
            offset: 50
        }],
        categoryAxis: {
            parseDates: true,
            minPeriod: 'fff',
            equalSpacing: true
        },
        startDuration: 0,
        graphs: [],
        plotAreaFillAlphas: 0.0,
        categoryField: "timestamp",
        'export': {
            enabled: false
        }
    };
}

return serialChart;

}); // define
